<!DOCTYPE html>
<html>
<head>
  <title>The Entropic Archive</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet">
  <style>
    body {
      background: black;
      color: white;
      font-family: monospace;
      padding: 2rem;
      margin: 0;
      overflow-x: hidden;
    }
    
    button:hover {
      background: #333;
    }
    
    .fragment {
      animation: flicker 1.2s infinite alternate;
      font-size: 1.2rem;
      margin: 1rem 0;
      position: relative;
      z-index: 1;
      white-space: pre-wrap;
    }

    #transmission-zone {
      display:flex;
      justify-content: center;
      align-items: center;
      min-height: 30vh;
      margin-bottom: 2rem;
      transition: all 0.6s ease-in-out;
    }

    .console-glass {
      background: rgba(20, 20, 30, 0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(120, 120, 200, 0.2);
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(100, 150, 255, 0.3);
      transition: all 0.3s ease;
      max-width: 600px;
      width: 100%;
    }

    .console-glass:hover {
      box-shadow: 0 0 40px rgba(75, 121, 207, 0.5);
    }

    textarea {
      background: transparent;
      color: #ccf;
      border: none;
      outline: none;
      width: 100%;
      resize:none;
      font-family: 'Space Mono', monospace;
      font-size: 1rem;
      line-height: 1.4;
      padding: 1rem;
      transition: all 0.3s ease;
    }

    textarea::placeholder {
      color: rgba(170, 200, 255, 0.3);
    }

    .transmit-button {
      margin-top: 1rem;
      padding: 0.5rem 1.2rem;
      background: rgba(90, 120, 255, 0.15);
      color: #88ccff;
      font-family: 'Space Mono', monospace;
      border: 1px solid rgba(136, 204, 255, 0.2);
      cursor: pointer;
      transition: all 0.4s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .transmit-button:hover {
      background: rgba(120, 160, 255, 0.25);
      color: white;
      letter-spacing: 2px;
      transform: scale(1.05);
      box-shadow: 0 0 12px rgba(136, 204, 255, 0.4);
    }
    
    @keyframes flicker {
      from { opacity: 1; }
      to { opacity: 0.5; transform: scale(1.01); }
    }

    @keyframes collapseIntoHole {
      0% {
        opacity: 1;
        transform: translate(-50%, 0) scale(1) rotate(0deg);
        filter: blur(0) hue-rotate(0deg);
        letter-spacing: normal;
      }
      50% {
        letter-spacing: 1px;
        transform: translate(-50%, 300px) scale(0.8) rotate(180deg);
        filter: blur(1px) hue-rotate(90deg);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, 600px) scale(0.1) rotate(720deg);
        filter: blur(3px) hue-rotate(180deg);
        letter-spacing: 3px;
      }
    }

    .falling-fragment {
      animation: collapseIntoHole 2.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      white-space: pre-wrap;
      font-size: 1.2rem;
      color: #00ff99;
      z-index: 10;
      pointer-events: none;
      text-shadow: 0 0 5px #00ff99;
      font-family: 'Courier New', Courier, monospace;
      will-change: transform, filter, opacity;
    }
    
    #blackhole-canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
      opacity: 0.7;
      width: 100%;
      height: 100%;
    }
    
    h1 {
      color: #4b79cf;
      text-align: center;
      margin-bottom: 2rem;
      position: relative;
      z-index: 1;
      text-shadow: 0 0 10px rgba(75, 121, 207, 0.5);
    }

    .cosmic-particle {
      position: absolute;
      color: rgba(136, 204, 255, 0.7);
      text-shadow: 0 0 8px #88ccff;
      pointer-events: none;
      font-size: 0.8rem;
      white-space: pre;
      transform-origin: center;
    }

    .floating-text {
      position: fixed;
      color: rgba(136, 204, 255, 0.9);
      text-shadow: 0 0 12px rgba(136, 204, 255, 0.8), 0 0 20px rgba(136, 204, 255, 0.4);
      pointer-events: none;
      font-size: 1rem;
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-line;
      z-index: 2;
      transition: all 0.5s ease;
      max-width: 180px;
      word-wrap: break-word;
      line-height: 1.3;
      animation: floatDrift 12s infinite ease-in-out;
      font-weight: bold;
    }

    @keyframes glitch{
      0% {transform: translate(0);}
      20% {transform: translate(-3px, 3px);}
      40% {transform: translate(-3px, -3px);}
      60% {transform: translate(3px, 3px);}
      80% {transform: translate(3px, -3px);}
      100% {transform: translate(0);}
    }

    .glitch-effect {
      animation: glitch 0.5s infinite;
    }

    @keyframes noise {
      0% { background-position: 0 0; }
      100% { background-position: 100% 100%; }
    }
    .noise-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      background-image: 
        linear-gradient(45deg, #fff 25%, transparent 25%),
        linear-gradient(-45deg, #fff 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #fff 75%),
        linear-gradient(-45deg, transparent 75%, #fff 75%);
      background-size: 4px 4px;
      animation: noise 0.2s infinite;
      pointer-events: none;
    }

    @keyframes floatDrift {
      0%, 100% { 
        transform: translateY(0px) rotate(0deg); 
        opacity: 0.9; 
      }
      25% { 
        transform: translateY(-25px) rotate(2deg); 
        opacity: 1; 
      }
      50% { 
        transform: translateY(15px) rotate(-1deg); 
        opacity: 0.7; 
      }
      75% { 
        transform: translateY(-20px) rotate(1deg); 
        opacity: 0.9; 
      }
    }

    .floating-text:hover {
      transform: scale(1.1);
      opacity: 1 !important;
      color: #88ccff;
      z-index: 5;
    }

    .entropy-graph {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 300px;
      height: 150px;
      background: rgba(20, 20, 30, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(136, 204, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
      z-index: 100;
      font-family: 'Space Mono', monospace;
      font-size: 0.8rem;
      color: #88ccff;
      transition: all 0.3s ease;
    }
    .entropy-graph:hover {
      box-shadow: 0 0 20px rgba(136, 204, 255, 0.5);
      transform: scale(1.05);
    }
    .graph-title {
      text-align: center;
      margin-bottom: 10px;
      color: #4b79cf;
      font-weight: bold;
      text-shadow: 0 0 5px rgba(75, 121, 207, 0.5);
    }
    .graph-canvas {
      width: 100%;
      height: 80px;
      border: 1px solid rgba(136, 204, 255, 0.2);
      background: rgba(0, 0, 0, 0.3);
    }
    .entropy-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 0.7rem;
      opacity: 0.8;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .stat-value {
      color: #88ccff;
      font-weight: bold;
    }

    .stat-label {
      color: rgba(136, 204, 255, 0.6);
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <canvas id="blackhole-canvas"></canvas>
  <h1>The Entropic Archive</h1>

  <div class="entropy-graph">
    <div class="graph-title">ENTROPIC ESCALATION</div>
    <canvas class="graph-canvas"></canvas>
    <div class="entropy-stats">
      <div class="stat-item">
        <div class="stat-value" id="current-entropy">0</div>
        <div class="stat-label">CURRENT</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="peak-entropy">0</div>
        <div class="stat-label">PEAK</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="time-elapsed">0s</div>
        <div class="stat-label">TIME</div>
      </div>
    </div>
  </div>

  <div id="transmission-zone">
    <form id="archive-form">
      <div class="console-glass">
      <textarea name="content" rows="3" placeholder="Submit your thoughts to the void..." required></textarea><br>
      <button type="submit" class="transmit-button">Collapse into the Archive</button>
      </div>
    </form>
  </div>

  <div id="submissions-container"></div>
  <div id="floating-texts-container"></div>

  <script>
    // ===== THREE.JS BLACK HOLE ANIMATION =====
    const canvas = document.getElementById('blackhole-canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
      canvas,
      antialias: true,
      alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);

    //Smoostep function
    function smoothstep(min, max, value) {
      const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
      return x * x * (3 - 2 * x);
    }

    //Starfield background
    const starGeometry = new THREE.BufferGeometry();
    const starMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.1,
      transparent: true,
    });

    const starVertices = [];
    for (let i = 0; i < 10000; i++) {
      const x = (Math.random() - 0.5) * 2000;
      const y = (Math.random() - 0.5) * 2000;
      const z = (Math.random() - 0.5) * 2000;
      starVertices.push(x, y, z);
    }

    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    //Shader for black hole
    const blackHoleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        distortion: { value: 2.5 },
        power: { value: 1.2 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float distortion;
        uniform float power;
        varying vec2 vUv;

        void main() {
          vec2 p = vUv * 2.0 - 1.0;
          float radius = length(p);
          if (radius > 0.95) discard;

          //Event horizon effect
          float distortionFactor = 1.0 - smoothstep(0.4, 0.95, radius);
          vec2 distortedUV = p * (1.0 + distortionFactor * distortion * 0.5);

          // Gravitational lensing effect
          float lensing = pow(1.0 - radius, power) * 2.0;
          vec2 lensedUV = distortedUV * (1.0 + lensing);

          // Inner glow
          float innerGlow = smoothstep(0.9, 0.3, radius);
          vec3 color = mix(vec3(0.0), vec3(0.2, 0.1, 0.5), innerGlow);

          // Pulsing effect
          float pulse = 0.5 + 0.5 * sin(time * 2.0);
          color += vec3(0.1, 0.05, 0.2) * pulse * (1.0 - radius);
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      side: THREE.DoubleSide,
      transparent: true,
    });

    // Black hole mesh
    const blackHole = new THREE.Mesh(
      new THREE.SphereGeometry(1.2, 64, 64),
      blackHoleMaterial
    );
    scene.add(blackHole);

    // Accretion disk
    const diskGeometry = new THREE.TorusGeometry(1.5, 0.5, 32, 100);
    const diskMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        glowColor: { value: new THREE.Color(0.8, 0.5, 1.0) },
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
          vUv = uv;
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 glowColor;
        varying vec2 vUv;
        varying vec3 vPosition;

        void main() {
          //Twist the disk texture
          float twistFactor = sin(time + vPosition.y * 5.0) * 0.2;
          vec2 twistedUV = vec2(vUv.x + twistFactor, vUv.y);

          //Glow effect
          float radial = 1.0 - abs(vUv.x * 2.0 - 1.0);
          float glow = pow(radial, 3.0);

          //Pulsing effect
          float pulse = 0.8 + 0.2 * sin(time * 3.0);

          //Doppler effect
          float doppler = vPosition.y * 0.5;
          vec3 shiftedColor = mix(
            vec3(1.0, 0.3, 0.2), // Redshift
            vec3(0.3, 0.4, 1.0), // Blueshift
            smoothstep(-0.5, 0.5, doppler)
          );

          //Final color
          vec3 color = mix(glowColor, shiftedColor, 0.7) * glow * pulse;
          float alpha = smoothstep(0.3, 0.8, glow);
          gl_FragColor = vec4(color, alpha * 0.9);
        }
      `,
      side: THREE.DoubleSide,
      transparent: true,
      blending: THREE.AdditiveBlending,
    }); 

    const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
    accretionDisk.rotation.x = Math.PI / 2;
    scene.add(accretionDisk);

    // Hawking radiation particles
    const particleGeometry = new THREE.BufferGeometry();
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x88ccff,
      size: 0.05,
      transparent: true,
      blending: THREE.AdditiveBlending,
    });

    const particlePositions = [];
    for (let i = 0; i < 500; i++) {
      const radius = 2.0 + Math.random() * 3.0;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2.0 * Math.random() - 1.0);
  
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
  
      particlePositions.push(x, y, z);
    }
    particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);
    camera.position.z = 4;

    // ===== ENTROPIC ESCALATION NOISE =====
    let entropyLevel = 0;
    let timeOnPage = 0;
    const maxEntropy = 100;
    let entropyInterval;
    let entropyHistory = [];
    let peakEntropy = 0;
    let startTime = Date.now();

    // ===== ENTROPY GRAPH FUNCTIONS =====
    function initEntropyGraph() {
      const canvas = document.querySelector('.graph-canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      drawEntropyGraph(ctx);
    }

    function drawEntropyGraph(ctx) {
      const canvas = ctx.canvas;
      const width = canvas.width;
      const height = canvas.height;
      const padding = 10;
      const graphWidth = width - padding * 2;
      const graphHeight = height - padding * 2;
      
      ctx.clearRect(0, 0, width, height);
      
      // Draw grid
      ctx.strokeStyle = 'rgba(136, 204, 255, 0.2)';
      ctx.lineWidth = 1;
      
      // Horizontal grid lines
      for (let i = 0; i <= 5; i++) {
        const y = padding + (graphHeight - (i * graphHeight / 5));
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
        
        // Grid labels
        ctx.fillStyle = 'rgba(136, 204, 255, 0.6)';
        ctx.font = '8px Space Mono';
        ctx.textAlign = 'right';
        ctx.fillText(Math.floor((i * maxEntropy) / 5), padding - 5, y + 3);
      }
      
      // Draw graph line
      if (entropyHistory.length > 1) {
        ctx.strokeStyle = '#4b79cf';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const maxTime = Math.max(60, entropyHistory[entropyHistory.length - 1].time);
        const xScale = graphWidth / maxTime;
        const yScale = graphHeight / maxEntropy;
        
        for (let i = 0; i < entropyHistory.length; i++) {
          const x = padding + (entropyHistory[i].time * xScale);
          const y = padding + (graphHeight - (entropyHistory[i].value * yScale));
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        
        // Draw fill
        ctx.fillStyle = 'rgba(75, 121, 207, 0.2)';
        ctx.beginPath();
        ctx.moveTo(padding, padding + graphHeight);
        for (let i = 0; i < entropyHistory.length; i++) {
          const x = padding + (entropyHistory[i].time * xScale);
          const y = padding + (graphHeight - (entropyHistory[i].value * yScale));
          ctx.lineTo(x, y);
        }
        ctx.lineTo(padding + (entropyHistory[entropyHistory.length - 1].time * xScale), padding + graphHeight);
        ctx.closePath();
        ctx.fill();
      }
      
      // Update stats
      document.getElementById('current-entropy').textContent = Math.floor(entropyLevel);
      document.getElementById('peak-entropy').textContent = Math.floor(peakEntropy);
      document.getElementById('time-elapsed').textContent = `${Math.floor((Date.now() - startTime) / 1000)}s`;
    }

    function updateEntropyGraph() {
      const currentTime = (Date.now() - startTime) / 1000;
      entropyHistory.push({
        time: currentTime,
        value: entropyLevel
      });
      
      if (entropyHistory.length > 100) {
        entropyHistory = entropyHistory.slice(-100);
      }
      
      if (entropyLevel > peakEntropy) {
        peakEntropy = entropyLevel;
      }
      
      const ctx = document.querySelector('.graph-canvas').getContext('2d');
      drawEntropyGraph(ctx);
    }

    function startEntropyEscalation() {
      initEntropyGraph(); // Initialize the graph
      
      entropyInterval = setInterval(() => {
        timeOnPage += 5;
        entropyLevel = Math.min(timeOnPage ** 0.7, maxEntropy);
        applyEntropicEffects();
        updateEntropyGraph(); // Update the graph with new data
      }, 5000);
    }

    function applyEntropicEffects() {
      if (entropyLevel < 5) return;

      const body = document.body;

      //1. Background flickering
      if(Math.random() < entropyLevel/150) {
        body.style.background = `rgb(${Math.floor(10 +entropyLevel/5)}, 0, 0)`;
        setTimeout(() => {
          body.style.background = 'black';
        }, 100);
      }

      //2. Text corruption
      const fragments = document.querySelectorAll('.fragment, .floating-text');
      fragments.forEach(el => {
        if (Math.random() < entropyLevel / 200) {
          const rotate = (Math.random() - 0.5) * entropyLevel/10;
          const skew = (Math.random() - 0.5) * entropyLevel/20;
          el.style.transform = `rotate(${rotate}deg) skew(${skew}deg)`;
        }

        if (Math.random() < entropyLevel/250) {
          const hue = Math.random() * 60 - 30;
          el.style.filter = `hue-rotate(${hue}deg)`;
          setTimeout(() => {
            el.style.filter = '';
          }, 1000 + Math.random() * 2000);
        }
      });

      //3. Layout Shifts
      if (Math.random() < entropyLevel / 300) {
        const container = document.getElementById('submissions-container');
        const shiftX = (Math.random() - 0.5) * entropyLevel / 2;
        const shiftY = (Math.random() - 0.5) * entropyLevel / 3;
        container.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
      }

      //4. Noise background
      if (entropyLevel > 30 && Math.random() < entropyLevel/400) {
        addNoiseParticles(1 + Math.floor(entropyLevel/20));
      }

      //5. Form distortion
      const form = document.getElementById('archive-form');
      if (entropyLevel > 50) {
        form.style.transform = `
          perspective(500px) 
          rotateX(${(Math.random() - 0.5) * entropyLevel/20}deg)
          rotateY(${(Math.random() - 0.5) * entropyLevel/20}deg)
          scale(${1 - entropyLevel / 1000})
        `;
      }

      //6. Black Hole becomes active
      if (entropyLevel > 40){
        blackHole.rotation.y += 0.001 * entropyLevel/20;
        accretionDisk.rotation.z += 0.002 * entropyLevel/20;
      }
    }

    function addNoiseParticles(count) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'cosmic-particle';
        particle.textContent = ['·', '∗', '✢', '⌇', '⟁'][Math.floor(Math.random() * 5)];
        particle.style.left = `${Math.random() * 100}vw`;
        particle.style.top = `${Math.random() * 100}vh`;
        particle.style.opacity = Math.random() * 0.5;
        particle.style.animation = `floatDrift ${Math.random() * 20}s infinite ease-in-out`;
        document.body.appendChild(particle);

        setTimeout(() => {
          particle.remove();
        }, 30000 + Math.random() * 30000);
      }
    }

    // ===== FORM HANDLING & COSMIC ENTROPY =====
    let activeSubmissions = [];
    let cosmicParticles = [];
    let floatingTextElements = [];

    try {
      cosmicParticles = JSON.parse(localStorage.getItem('cosmicParticles')) || [];
    } catch (e) {
      cosmicParticles = [];
    }

    if (cosmicParticles.length === 0) {
      try {
        const oldSubmissions = JSON.parse(localStorage.getItem('submissions')) || [];
        cosmicParticles = oldSubmissions.map(sub => ({
          content: applyHeavyEntropy(sub.content),
          x: Math.random() * 4 - 2,
          y: Math.random() * 4 - 2,
          z: Math.random() * 4 - 2
        }));
        if (cosmicParticles.length > 0) {
          localStorage.setItem('cosmicParticles', JSON.stringify(cosmicParticles));
          localStorage.removeItem('submissions');
        }
      } catch (e) {
        cosmicParticles = [];
      }
    }

    function initializeCosmicParticles() {
      cosmicParticles.forEach(particle => {
        addParticleToScene(particle);
        createFloatingText(particle);
      });
    }

    function addParticleToScene(particle) {
      const geom = new THREE.SphereGeometry(0.03, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ 
        color: 0x88ccff,
        transparent: true,
        opacity: 0.7
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(particle.x, particle.y, particle.z);
      mesh.userData = { 
        isParticle: true,
        originalContent: particle.content
      };
      scene.add(mesh);
    }

    function createFloatingText(particle) {
      const textElement = document.createElement('div');
      textElement.className = 'floating-text';
      textElement.textContent = particle.content;
      
      const isSpaghettified = particle.content.includes('\n');
      const isHeavilyCorrupted = particle.content.includes('⟁⟁⟁') || particle.content.includes('★★★');
      
      let x, y, maxWidth, fontSize;
      
      if (isSpaghettified) {
        x = Math.random() * (window.innerWidth - 100) + 50;
        y = Math.random() * (window.innerHeight - 300) + 100;
        maxWidth = 60;
        fontSize = '0.9rem';
      } else if (isHeavilyCorrupted) {
        x = Math.random() * (window.innerWidth - 150) + 75;
        y = Math.random() * (window.innerHeight - 200) + 100;
        maxWidth = 120;
        fontSize = '1rem';
      } else {
        x = Math.random() * (window.innerWidth - 200) + 100;
        y = Math.random() * (window.innerHeight - 150) + 75;
        maxWidth = 200;
        fontSize = '1.1rem';
      }
      
      textElement.style.left = x + 'px';
      textElement.style.top = y + 'px';
      textElement.style.maxWidth = maxWidth + 'px';
      textElement.style.fontSize = fontSize;
      textElement.style.animationDelay = Math.random() * 10 + 's';
      
      document.getElementById('floating-texts-container').appendChild(textElement);
      floatingTextElements.push({
        element: textElement,
        baseX: x,
        baseY: y,
        driftX: 0,
        driftY: 0,
        type: isSpaghettified ? 'spaghetti' : (isHeavilyCorrupted ? 'corrupted' : 'readable')
      });
    }

    document.getElementById('archive-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const content = e.target.content.value.trim();
      if (!content) return;
      
      createFallingElement(content, e.target);
      
      activeSubmissions.push({
        content,
        createdAt: new Date().toISOString()
      });
      
      renderActiveSubmissions();
      e.target.reset();
    });

    function createFallingElement(text, formElement) {
      const fallingElement = document.createElement('div');
      fallingElement.className = 'falling-fragment';
      fallingElement.textContent = text;
      
      const formRect = formElement.getBoundingClientRect();
      fallingElement.style.left = `${formRect.left + formRect.width/2}px`;
      fallingElement.style.top = `${formRect.bottom}px`;
      
      document.body.appendChild(fallingElement);

      let progress = 0;
      const corruptInterval = setInterval(() => {
        progress += 0.05;
        fallingElement.textContent = applyProgressiveEntropy(text, progress);
        
        if (progress >= 1) {
          clearInterval(corruptInterval);
          setTimeout(() => {
            if (document.body.contains(fallingElement)) {
              fallingElement.remove();
            }
            convertToCosmicParticle(text);
          }, 500);
        }
      }, 100);
    }

    function convertToCosmicParticle(text) {
      const particle = {
        content: applyHeavyEntropy(text),
        x: Math.random() * 4 - 2,
        y: Math.random() * 4 - 2,
        z: Math.random() * 4 - 2
      };
      cosmicParticles.push(particle);
      
      try {
        localStorage.setItem('cosmicParticles', JSON.stringify(cosmicParticles));
      } catch (e) {
        console.log('Storage unavailable, keeping in memory only');
      }
      
      addParticleToScene(particle);
      createFloatingText(particle);
    }

    function applyProgressiveEntropy(text, progress) {
      const chars = [...text];
      const corruptionRate = Math.min(Math.floor(progress * 100), 100);
      const symbols = ['★', '✧', '♆', '⌇', '⟁', '⍟'];
      
      for (let i = 0; i < corruptionRate; i++) {
        if (chars.length) {
          const idx = Math.floor(Math.random() * chars.length);
          chars[idx] = symbols[Math.floor(Math.random() * symbols.length)];
        }
      }
      
      if (progress > 0.8) {
        return chars.join('').split('').join('\n');
      }
      
      return chars.join('');
    }

    function applyHeavyEntropy(text) {
      const chars = [...text];
      const entropyType = Math.random();
      
      if (entropyType < 0.4) {
        for (let i = 0; i < chars.length; i++) {
          if (Math.random() > 0.3) {
            chars[i] = ['★', '✧', '♆', '⌇', '⟁', '⍟', '*', '~'][Math.floor(Math.random() * 8)];
          }
        }
        return chars.join('').split('').join('\n');
      } else if (entropyType < 0.7) {
        for (let i = 0; i < chars.length; i++) {
          if (Math.random() > 0.6) {
            chars[i] = ['★', '✧', '♆', '⌇', '⟁', '⍟'][Math.floor(Math.random() * 6)];
          }
        }
        return chars.join('');
      } else {
        const words = text.split(' ');
        return words.map(word => {
          if (Math.random() > 0.5) {
            return word.split('').map(c => 
              Math.random() > 0.4 ? c : ['★', '✧', '♆', '⌇'][Math.floor(Math.random() * 4)]
            ).join('');
          }
          return ['⟁⟁⟁', '★★★', '♆♆', '⌇⌇⌇'][Math.floor(Math.random() * 4)];
        }).join(' ');
      }
    }

    function applyEntropy(text, elapsedSeconds) {
      const chars = [...text];
      const corruptionRate = Math.min(Math.floor(elapsedSeconds ** 0.7), 100);
      const symbols = ['★', '✧', '♆', '⌇', '⟁', '⍟'];
      
      for (let i = 0; i < corruptionRate; i++) {
        if (chars.length) {
          const idx = Math.floor(Math.random() * chars.length);
          chars[idx] = symbols[Math.floor(Math.random() * symbols.length)];
        }
      }
      
      return elapsedSeconds > 60 ? chars.join('').split('').join('\n') : chars.join('');
    }

    function renderActiveSubmissions() {
      const container = document.getElementById('submissions-container');
      container.innerHTML = activeSubmissions.map(sub => {
        const elapsedSeconds = (new Date() - new Date(sub.createdAt)) / 1000;
        return `<p class="fragment">${applyEntropy(sub.content, elapsedSeconds)}</p>`;
      }).join('');
    }

    function updateFloatingTexts() {
      floatingTextElements.forEach((textObj, index) => {
        let driftMultiplier = 1;
        if (textObj.type === 'spaghetti') {
          driftMultiplier = 0.5;
          textObj.driftX += (Math.random() - 0.5) * 0.1;
          textObj.driftY += (Math.random() - 0.5) * 0.4;
        } else if (textObj.type === 'corrupted') {
          driftMultiplier = 1.2;
          textObj.driftX += (Math.random() - 0.5) * 0.4;
          textObj.driftY += (Math.random() - 0.5) * 0.4;
        } else {
          textObj.driftX += (Math.random() - 0.5) * 0.2;
          textObj.driftY += (Math.random() - 0.5) * 0.2;
        }
        
        const maxDrift = textObj.type === 'spaghetti' ? 30 : 50;
        textObj.driftX = Math.max(-maxDrift, Math.min(maxDrift, textObj.driftX));
        textObj.driftY = Math.max(-maxDrift, Math.min(maxDrift, textObj.driftY));
        
        const newX = textObj.baseX + textObj.driftX;
        const newY = textObj.baseY + textObj.driftY;
        
        const elementWidth = textObj.type === 'spaghetti' ? 60 : (textObj.type === 'corrupted' ? 120 : 200);
        if (newX < 0 || newX > window.innerWidth - elementWidth) {
          textObj.driftX *= -0.5;
        }
        if (newY < 0 || newY > window.innerHeight - 100) {
          textObj.driftY *= -0.5;
        }
        
        textObj.element.style.left = Math.max(0, Math.min(window.innerWidth - elementWidth, newX)) + 'px';
        textObj.element.style.top = Math.max(0, Math.min(window.innerHeight - 100, newY)) + 'px';
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const time = performance.now() * 0.001;
      blackHoleMaterial.uniforms.time.value = time;
      diskMaterial.uniforms.time.value = time;

      blackHole.rotation.y = time * 0.1;
      accretionDisk.rotation.z = time * 0.5;

      const positions = particles.geometry.attributes.position.array;
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];

        const distance = Math.sqrt(x * x + y * y + z * z);
        const fallFactor = 0.98 - (0.02 * (1.0 - smoothstep(1.0, 3.0, distance)));
        const stretch = 1.0 + (2.0 / (distance + 0.1));
        positions[i] = x * fallFactor;
        positions[i+1] = y * fallFactor;
        positions[i+2] = z * fallFactor * stretch;

        if (distance < 0.5) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2.0 * Math.random() - 1.0);
          const radius = 3.0 + Math.random() * 2.0;

          positions[i] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i+1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i+2] = radius * Math.cos(phi);
        }
      }
      particles.geometry.attributes.position.needsUpdate = true;
      
      scene.children.filter(child => child.userData?.isParticle).forEach(p => {
        p.position.x += (Math.random() - 0.5) * 0.01;
        p.position.y += (Math.random() - 0.5) * 0.01;
        p.position.z += (Math.random() - 0.5) * 0.01;
        p.position.x *= 0.995;
        p.position.y *= 0.995;
        p.position.z *= 0.995;
      });
      
      // Update graph periodically (more frequently than the entropy escalation)
      if (Date.now() % 1000 < 16) { // ~once per second
        updateEntropyGraph();
      }
      
      updateFloatingTexts();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      floatingTextElements.forEach(textObj => {
        textObj.baseX = Math.random() * (window.innerWidth - 200) + 100;
        textObj.baseY = Math.random() * (window.innerHeight - 200) + 100;
      });
    });

    startEntropyEscalation();
    initializeCosmicParticles();
    animate();
    renderActiveSubmissions();
  </script>
</body>
</html>
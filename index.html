<!DOCTYPE html>
<html>
<head>
  <title>The Entropic Archive</title>
  <style>
    body {
      background: black;
      color: white;
      font-family: monospace;
      padding: 2rem;
      margin: 0;
      overflow-x: hidden;
    }
    
    form {
      margin-bottom: 2rem;
      position: relative;
      z-index: 1;
      transition: all 1s ease;
    }
    
    form:hover {
      transform: perspective(500px) rotateX(10deg) scale(0.98);
      filter: blur(0.5px);
    }
    
    textarea {
      width: 100%;
      background: #111;
      color: #0f0;
      border: 1px solid #0e0808;
      padding: 1rem;
      font-family: monospace;
      resize: vertical;
      min-height: 100px;
    }
    
    button {
      margin-top: 0.5rem;
      padding: 0.5rem 1rem;
      background: #222;
      color: white;
      border: 1px solid #555;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    button:hover {
      background: #333;
    }
    
    .fragment {
      animation: flicker 1.2s infinite alternate;
      font-size: 1.2rem;
      margin: 1rem 0;
      position: relative;
      z-index: 1;
      white-space: pre-wrap;
    }
    
    @keyframes flicker {
      from { opacity: 1; }
      to { opacity: 0.5; transform: scale(1.01); }
    }

    @keyframes collapseIntoHole {
      0% {
        opacity: 1;
        transform: translate(-50%, 0) scale(1) rotate(0deg);
        filter: blur(0) hue-rotate(0deg);
        letter-spacing: normal;
      }
      50% {
        letter-spacing: 1px;
        transform: translate(-50%, 300px) scale(0.8) rotate(180deg);
        filter: blur(1px) hue-rotate(90deg);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, 600px) scale(0.1) rotate(720deg);
        filter: blur(3px) hue-rotate(180deg);
        letter-spacing: 3px;
      }
    }

    .falling-fragment {
      animation: collapseIntoHole 2.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      white-space: pre-wrap;
      font-size: 1.2rem;
      color: #00ff99;
      z-index: 10;
      pointer-events: none;
      text-shadow: 0 0 5px #00ff99;
      font-family: 'Courier New', Courier, monospace;
      will-change: transform, filter, opacity;
    }
    
    #blackhole-canvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
      opacity: 0.7;
      width: 100%;
      height: 100%;
    }
    
    h1 {
      color: #4b79cf;
      text-align: center;
      margin-bottom: 2rem;
      position: relative;
      z-index: 1;
      text-shadow: 0 0 10px rgba(75, 121, 207, 0.5);
    }

    .cosmic-particle {
      position: absolute;
      color: rgba(136, 204, 255, 0.7);
      text-shadow: 0 0 8px #88ccff;
      pointer-events: none;
      font-size: 0.8rem;
      white-space: pre;
      transform-origin: center;
    }

    /* New floating text styles */
    .floating-text {
      position: fixed;
      color: rgba(136, 204, 255, 0.9);
      text-shadow: 0 0 12px rgba(136, 204, 255, 0.8), 0 0 20px rgba(136, 204, 255, 0.4);
      pointer-events: none;
      font-size: 1rem;
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-line;
      z-index: 2;
      transition: all 0.5s ease;
      max-width: 180px;
      word-wrap: break-word;
      line-height: 1.3;
      animation: floatDrift 12s infinite ease-in-out;
      font-weight: bold;
    }

    @keyframes glitch{
      0% {transform: translate(0);}
      20% {transform: translate(-3px, 3px);}
      40% {transform: translate(-3px, -3px);}
      60% {transform: translate(3px, 3px);}
      80% {transform: translate(3px, -3px);}
      100% {transform: translate(0);}
    }

    .glitch-effect {
      animation: glitch 0.5s infinite;
    }

    @keyframes noise {
      0% { background-position: 0 0; }
      100% { background-position: 100% 100%; }
    }
    .noise-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      background-image: 
        linear-gradient(45deg, #fff 25%, transparent 25%),
        linear-gradient(-45deg, #fff 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #fff 75%),
        linear-gradient(-45deg, transparent 75%, #fff 75%);
      background-size: 4px 4px;
      animation: noise 0.2s infinite;
      pointer-events: none;
    }

    @keyframes floatDrift {
      0%, 100% { 
        transform: translateY(0px) rotate(0deg); 
        opacity: 0.9; 
      }
      25% { 
        transform: translateY(-25px) rotate(2deg); 
        opacity: 1; 
      }
      50% { 
        transform: translateY(15px) rotate(-1deg); 
        opacity: 0.7; 
      }
      75% { 
        transform: translateY(-20px) rotate(1deg); 
        opacity: 0.9; 
      }
    }

    .floating-text:hover {
      transform: scale(1.1);
      opacity: 1 !important;
      color: #88ccff;
      z-index: 5;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
  <canvas id="blackhole-canvas"></canvas>
  <h1>The Entropic Archive</h1>

  <form id="archive-form">
    <textarea name="content" rows="3" placeholder="Submit your thoughts to the void..." required></textarea><br>
    <button type="submit">Collapse into the Archive</button>
  </form>

  <div id="submissions-container"></div>
  <div id="floating-texts-container"></div>

  <script>
    // ===== THREE.JS BLACK HOLE ANIMATION =====
    const canvas = document.getElementById('blackhole-canvas');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Black hole core
    const blackHole = new THREE.Mesh(
      new THREE.SphereGeometry(1, 64, 64),
      new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.9 })
    );
    scene.add(blackHole);

    // Accretion disk
    const accretionDisk = new THREE.Mesh(
      new THREE.TorusGeometry(1.5, 0.3, 16, 100),
      new THREE.MeshBasicMaterial({ 
        color: 0x4b79cf, 
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.8
      })
    );
    accretionDisk.rotation.x = Math.PI / 2;
    scene.add(accretionDisk);

    // Hawking radiation particles
    const particles = new THREE.Group();
    scene.add(particles);
    for (let i = 0; i < 100; i++) {
      const particle = new THREE.Mesh(
        new THREE.SphereGeometry(0.05, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0x88ccff })
      );
      particle.position.set(
        Math.random() * 4 - 2,
        Math.random() * 4 - 2,
        Math.random() * 4 - 2
      );
      particles.add(particle);
    }

    camera.position.z = 5;

    // ===== ENTROPIC ESCALATION NOISE =====
    let entropyLevel =0;
    let timeOnPage = 0;
    const maxEntropy = 100; // Maximum entropy level
    let entropyInterval;

    // Start entropy escalation when the page loads
    function startEntropyEscalation() {
      entropyInterval = setInterval(() => {
        timeOnPage += 5;
        entropyLevel = Math.min(timeOnPage ** 0.7, maxEntropy);
        applyEntropicEffects();
      }, 5000);
    }

    //Apply visual effects based on entropy levels
    function applyEntropicEffects() {
      if (entropyLevel < 5) return;

      const body = document.body;

      //1. Background flickering
      if(Math.random() < entropyLevel/150) {
        body.style.background = `rgb($(Math.floor(10 +entropyLevel/5)}, 0, 0)`;
        setTimeout(() => {
          body.style.background = 'black';
        }, 100);
      }
    }

    //2. Text corruption
    const fragments = document.querySelectorAll('.fragment, .floating-text');
    fragments.forEach(el => {
      if (Math.random() < entropyLevel / 200) {
        const rotate = (Math.random() - 0.5) * entropyLevel/10;
        const skew = (Math.random() - 0.5) * entropyLevel/20;
        el.style.transform = `rotate(${rotate}deg) skew(${skew}deg)`;
      }

      //random color shift
      if (Math.random() < entropyLevel/250) {
        const hue = Math.random() * 60 - 30;
        el.style.filter = `hue-rotate(${hue}deg)`;
        setTimeout(() => {
          el.style.filter = '';
        }, 1000 + Math.random() * 2000);
      }
    });

    //3. Layout Shifts
    if (Math.random() < entropyLevel / 300) {
      const container = document.getElementById('submissions-container');
      const shiftX = (Math.random() - 0.5) * entropyLevel / 2;
      const shiftY = (Math.random() - 0.5) * entropyLevel / 3;
      container.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
    }

    //4. Noise background
    if (entropyLevel > 30 && Math.random() < entropyLevel/400) {
      addNoiseParticles(1 + Math.floor(entropyLevel/20));
    }

    //5. Form distortion
    const form = document.getElementById('archive-form');
    if (entropyLevel > 50) {
      form.style.transform = `
        perspective(500px) 
        rotateX(${(Math.random() - 0.5) * entropyLevel/20}deg)
        rotateY($({Math.random() - 0.5) * entropyLevel/20}deg)
        scale(${1 - entropyLevel / 1000})
      `;
    }

    //6. Black Hole becomes active
    if (entropyLevel > 40){
      blackHole.rotation.y += 0.001 * entropyLevel/20;
      accretionDisk.rotation.z += 0.002 * entropyLevel/20;
    }

    //Noise particle generation
    function addNoiseParticles(count) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'cosmic-particle';
        particle.textContent = ['·', '∗', '✢', '⌇', '⟁'][Math.floor(Math.random() * 5)];
        particle.style.left = `${Math.random() * 100}vw`;
        particle.style.top = `${Math.random() * 100}vh`;
        particle.style.opacity = Math.random() * 0.5;
        particle.style.animation = `floatDrift ${Math.random() * 20}s infinite ease-in-out`;
        document.body.appendChild(particle);

        setTimeout(() => {
          particle.remove();
        }, 30000 + Math.random() * 30000);
      }
    }
        

    // ===== FORM HANDLING & COSMIC ENTROPY =====
    let activeSubmissions = [];
    let cosmicParticles = [];
    let floatingTextElements = [];

    // Load cosmic particles from localStorage (no localStorage restriction applies to loading existing data)
    try {
      cosmicParticles = JSON.parse(localStorage.getItem('cosmicParticles')) || [];
    } catch (e) {
      cosmicParticles = [];
    }

    // Convert old submissions to particles on load if no cosmic particles exist
    if (cosmicParticles.length === 0) {
      try {
        const oldSubmissions = JSON.parse(localStorage.getItem('submissions')) || [];
        cosmicParticles = oldSubmissions.map(sub => ({
          content: applyHeavyEntropy(sub.content),
          x: Math.random() * 4 - 2,
          y: Math.random() * 4 - 2,
          z: Math.random() * 4 - 2
        }));
        if (cosmicParticles.length > 0) {
          localStorage.setItem('cosmicParticles', JSON.stringify(cosmicParticles));
          localStorage.removeItem('submissions');
        }
      } catch (e) {
        cosmicParticles = [];
      }
    }

    // Initialize cosmic particles in the scene
    function initializeCosmicParticles() {
      cosmicParticles.forEach(particle => {
        addParticleToScene(particle);
        createFloatingText(particle);
      });
    }

    function addParticleToScene(particle) {
      const geom = new THREE.SphereGeometry(0.03, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ 
        color: 0x88ccff,
        transparent: true,
        opacity: 0.7
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(particle.x, particle.y, particle.z);
      mesh.userData = { 
        isParticle: true,
        originalContent: particle.content
      };
      scene.add(mesh);
    }

    function createFloatingText(particle) {
      const textElement = document.createElement('div');
      textElement.className = 'floating-text';
      textElement.textContent = particle.content;
      
      // Different positioning and sizing based on entropy type
      const isSpaghettified = particle.content.includes('\n');
      const isHeavilyCorrupted = particle.content.includes('⟁⟁⟁') || particle.content.includes('★★★');
      
      let x, y, maxWidth, fontSize;
      
      if (isSpaghettified) {
        // Spaghettified texts - position more vertically, smaller width
        x = Math.random() * (window.innerWidth - 100) + 50;
        y = Math.random() * (window.innerHeight - 300) + 100;
        maxWidth = 60;
        fontSize = '0.9rem';
      } else if (isHeavilyCorrupted) {
        // Heavily corrupted chunks - medium positioning
        x = Math.random() * (window.innerWidth - 150) + 75;
        y = Math.random() * (window.innerHeight - 200) + 100;
        maxWidth = 120;
        fontSize = '1rem';
      } else {
        // Partially readable - wider positioning
        x = Math.random() * (window.innerWidth - 200) + 100;
        y = Math.random() * (window.innerHeight - 150) + 75;
        maxWidth = 200;
        fontSize = '1.1rem';
      }
      
      textElement.style.left = x + 'px';
      textElement.style.top = y + 'px';
      textElement.style.maxWidth = maxWidth + 'px';
      textElement.style.fontSize = fontSize;
      
      // Add random animation delay
      textElement.style.animationDelay = Math.random() * 10 + 's';
      
      document.getElementById('floating-texts-container').appendChild(textElement);
      floatingTextElements.push({
        element: textElement,
        baseX: x,
        baseY: y,
        driftX: 0,
        driftY: 0,
        type: isSpaghettified ? 'spaghetti' : (isHeavilyCorrupted ? 'corrupted' : 'readable')
      });
    }

    document.getElementById('archive-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const content = e.target.content.value.trim();
      if (!content) return;
      
      createFallingElement(content, e.target);
      
      // Add to active submissions
      activeSubmissions.push({
        content,
        createdAt: new Date().toISOString()
      });
      
      renderActiveSubmissions();
      e.target.reset();
    });

    function createFallingElement(text, formElement) {
      const fallingElement = document.createElement('div');
      fallingElement.className = 'falling-fragment';
      fallingElement.textContent = text;
      
      const formRect = formElement.getBoundingClientRect();
      fallingElement.style.left = `${formRect.left + formRect.width/2}px`;
      fallingElement.style.top = `${formRect.bottom}px`;
      
      document.body.appendChild(fallingElement);

      let progress = 0;
      const corruptInterval = setInterval(() => {
        progress += 0.05;
        fallingElement.textContent = applyProgressiveEntropy(text, progress);
        
        if (progress >= 1) {
          clearInterval(corruptInterval);
          setTimeout(() => {
            if (document.body.contains(fallingElement)) {
              fallingElement.remove();
            }
            // Convert to cosmic particle when animation ends
            convertToCosmicParticle(text);
          }, 500);
        }
      }, 100);
    }

    function convertToCosmicParticle(text) {
      const particle = {
        content: applyHeavyEntropy(text),
        x: Math.random() * 4 - 2,
        y: Math.random() * 4 - 2,
        z: Math.random() * 4 - 2
      };
      cosmicParticles.push(particle);
      
      try {
        localStorage.setItem('cosmicParticles', JSON.stringify(cosmicParticles));
      } catch (e) {
        console.log('Storage unavailable, keeping in memory only');
      }
      
      addParticleToScene(particle);
      createFloatingText(particle);
    }

    function applyProgressiveEntropy(text, progress) {
      const chars = [...text];
      const corruptionRate = Math.min(Math.floor(progress * 100), 100);
      const symbols = ['★', '✧', '♆', '⌇', '⟁', '⍟'];
      
      for (let i = 0; i < corruptionRate; i++) {
        if (chars.length) {
          const idx = Math.floor(Math.random() * chars.length);
          chars[idx] = symbols[Math.floor(Math.random() * symbols.length)];
        }
      }
      
      if (progress > 0.8) {
        return chars.join('').split('').join('\n');
      }
      
      return chars.join('');
    }

    function applyHeavyEntropy(text) {
      const chars = [...text];
      const entropyType = Math.random();
      
      if (entropyType < 0.4) {
        // Type 1: Spaghettified (stretched into lines)
        for (let i = 0; i < chars.length; i++) {
          if (Math.random() > 0.3) {
            chars[i] = ['★', '✧', '♆', '⌇', '⟁', '⍟', '*', '~'][Math.floor(Math.random() * 8)];
          }
        }
        return chars.join('').split('').join('\n');
      } else if (entropyType < 0.7) {
        // Type 2: Partially corrupted but readable
        for (let i = 0; i < chars.length; i++) {
          if (Math.random() > 0.6) {
            chars[i] = ['★', '✧', '♆', '⌇', '⟁', '⍟'][Math.floor(Math.random() * 6)];
          }
        }
        return chars.join('');
      } else {
        // Type 3: Heavily corrupted chunks
        const words = text.split(' ');
        return words.map(word => {
          if (Math.random() > 0.5) {
            return word.split('').map(c => 
              Math.random() > 0.4 ? c : ['★', '✧', '♆', '⌇'][Math.floor(Math.random() * 4)]
            ).join('');
          }
          return ['⟁⟁⟁', '★★★', '♆♆', '⌇⌇⌇'][Math.floor(Math.random() * 4)];
        }).join(' ');
      }
    }

    function applyEntropy(text, elapsedSeconds) {
      const chars = [...text];
      const corruptionRate = Math.min(Math.floor(elapsedSeconds ** 0.7), 100);
      const symbols = ['★', '✧', '♆', '⌇', '⟁', '⍟'];
      
      for (let i = 0; i < corruptionRate; i++) {
        if (chars.length) {
          const idx = Math.floor(Math.random() * chars.length);
          chars[idx] = symbols[Math.floor(Math.random() * symbols.length)];
        }
      }
      
      return elapsedSeconds > 60 ? chars.join('').split('').join('\n') : chars.join('');
    }

    function renderActiveSubmissions() {
      const container = document.getElementById('submissions-container');
      container.innerHTML = activeSubmissions.map(sub => {
        const elapsedSeconds = (new Date() - new Date(sub.createdAt)) / 1000;
        return `<p class="fragment">${applyEntropy(sub.content, elapsedSeconds)}</p>`;
      }).join('');
    }

    function updateFloatingTexts() {
      floatingTextElements.forEach((textObj, index) => {
        // Different movement patterns based on type
        let driftMultiplier = 1;
        if (textObj.type === 'spaghetti') {
          driftMultiplier = 0.5; // Slower, more vertical drift
          textObj.driftX += (Math.random() - 0.5) * 0.1;
          textObj.driftY += (Math.random() - 0.5) * 0.4;
        } else if (textObj.type === 'corrupted') {
          driftMultiplier = 1.2; // More erratic movement
          textObj.driftX += (Math.random() - 0.5) * 0.4;
          textObj.driftY += (Math.random() - 0.5) * 0.4;
        } else {
          // Readable texts move more smoothly
          textObj.driftX += (Math.random() - 0.5) * 0.2;
          textObj.driftY += (Math.random() - 0.5) * 0.2;
        }
        
        // Constrain drift based on type
        const maxDrift = textObj.type === 'spaghetti' ? 30 : 50;
        textObj.driftX = Math.max(-maxDrift, Math.min(maxDrift, textObj.driftX));
        textObj.driftY = Math.max(-maxDrift, Math.min(maxDrift, textObj.driftY));
        
        // Apply position
        const newX = textObj.baseX + textObj.driftX;
        const newY = textObj.baseY + textObj.driftY;
        
        // Keep within bounds
        const elementWidth = textObj.type === 'spaghetti' ? 60 : (textObj.type === 'corrupted' ? 120 : 200);
        if (newX < 0 || newX > window.innerWidth - elementWidth) {
          textObj.driftX *= -0.5;
        }
        if (newY < 0 || newY > window.innerHeight - 100) {
          textObj.driftY *= -0.5;
        }
        
        textObj.element.style.left = Math.max(0, Math.min(window.innerWidth - elementWidth, newX)) + 'px';
        textObj.element.style.top = Math.max(0, Math.min(window.innerHeight - 100, newY)) + 'px';
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      blackHole.rotation.y += 0.005;
      accretionDisk.rotation.z += 0.02;
      
      // Move Hawking radiation particles
      particles.children.forEach(p => {
        p.position.x += (Math.random() - 0.5) * 0.02;
        p.position.y += Math.random() * 0.03;
        p.position.z += (Math.random() - 0.5) * 0.01;
        if (p.position.y > 3) p.position.y = -3;
      });
      
      // Move cosmic particles
      scene.children.filter(child => child.userData?.isParticle).forEach(p => {
        // Orbit around black hole with slight randomness
        p.position.x += (Math.random() - 0.5) * 0.01;
        p.position.y += (Math.random() - 0.5) * 0.01;
        p.position.z += (Math.random() - 0.5) * 0.01;
        
        // Slight pull toward center
        p.position.x *= 0.995;
        p.position.y *= 0.995;
        p.position.z *= 0.995;
      });
      
      // Update floating text positions
      updateFloatingTexts();
      
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Reposition floating texts on resize
      floatingTextElements.forEach(textObj => {
        textObj.baseX = Math.random() * (window.innerWidth - 200) + 100;
        textObj.baseY = Math.random() * (window.innerHeight - 200) + 100;
      });
    });

    // Initialize and start everything
    startEntropyEscalation();
    initializeCosmicParticles();
    animate();
    renderActiveSubmissions();
  </script>
</body>
</html>